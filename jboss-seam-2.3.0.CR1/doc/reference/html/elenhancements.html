<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Chapter 34. JBoss EL</title><link rel="stylesheet" href="css/seamframework.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><link rel="home" href="index.html" title="Seam - Contextual Components"/><link rel="up" href="index.html" title="Seam - Contextual Components"/><link rel="prev" href="controls.html" title="Chapter 33. Seam JSF controls"/><link rel="next" href="ClusteringAndEJBPassivation.html" title="Chapter 35. Clustering and EJB Passivation"/></head><body><p id="title"><a href="http://www.seamframework.org" class="site_href"><strong>SeamFramework.org</strong></a><a href="http://www.seamframework.org/Documentation" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="controls.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="ClusteringAndEJBPassivation.html"><strong>Next</strong></a></li></ul><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="elenhancements"/>Chapter 34. JBoss EL</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="elenhancements.html#d0e29346">34.1. Parameterized Expressions</a></span></dt><dd><dl><dt><span class="section"><a href="elenhancements.html#d0e29374">34.1.1. Usage</a></span></dt><dt><span class="section"><a href="elenhancements.html#d0e29438">34.1.2. Limitations and Hints</a></span></dt></dl></dd><dt><span class="section"><a href="elenhancements.html#d0e29537">34.2. Projection</a></span></dt></dl></div><p>
      Seam uses JBoss EL which provides an extension to the standard Unified 
      Expression Language (EL). JBoss EL provides a number of enhancements that 
      increase the expressiveness and power of EL expressions. 
   </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e29346"/>34.1. Parameterized Expressions</h2></div></div></div><p>
         Standard EL 2.1 does not allow you to use a method with user defined 
         parameters — of course, JSF listener methods (e.g. a 
         <code class="literal">valueChangeListener</code>) take parameters provided by JSF.
         <a class="ulink" href="http://docs.oracle.com/javaee/6/tutorial/doc/gjddd.html">Standard EL 2.2</a>,
          which is in Java EE 6, allows it now. So you don't have to use JBoss EL enhancements. 
      </p><p>You can still use JBoss EL instead of standard EL 2.2 from Java EE 6 by 
      setting up <code class="literal">com.sun.faces.expressionFactory</code> in <code class="filename">web.xml</code>:
      </p><pre class="programlisting">&lt;context-param&gt;
    &lt;param-name&gt;com.sun.faces.expressionFactory&lt;/param-name&gt;
    &lt;param-value&gt;org.jboss.el.ExpressionFactoryImpl&lt;/param-value&gt;
&lt;/context-param&gt;</pre><p>
      </p><p> 
         JBoss EL and EL 2.2 removed this restriction. For example: 
      </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XHTML"><!-- XHTML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">h:commandButton</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">action</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;#{hotelBooking.bookHotel(hotel)}&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">value</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Book&nbsp;Hotel&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
</pre><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">@</span><!-- <br/> --><span class="java_type">Name</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">&quot;hotelBooking&quot;</span><!-- <br/> --><span class="java_separator">)</span>
<!--  --><br/><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_keyword">class</span><span class="java_plain">&nbsp;</span><span class="java_type">HotelBooking</span><span class="java_plain">&nbsp;</span>
<!--  --><br/><span class="java_separator">{</span><span class="java_plain">&nbsp;&nbsp;&nbsp;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">String</span><span class="java_plain">&nbsp;bookHotel</span><span class="java_separator">(</span><span class="java_type">Hotel</span><span class="java_plain">&nbsp;hotel</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Book</span><span class="java_plain">&nbsp;the&nbsp;hotel</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span>
<!--  --><br/><span class="java_separator">}</span></pre><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e29374"/>34.1.1. Usage</h3></div></div></div><p>
            Just as in calls to method from Java, parameters are surrounded by 
            parentheses, and separated by commas: 
         </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XHTML"><!-- XHTML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">h:commandButton</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">action</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;#{hotelBooking.bookHotel(hotel,&nbsp;user)}&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">value</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Book&nbsp;Hotel&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
</pre><p> 
            The parameters <code class="literal">hotel</code> and <code class="literal">user</code> 
            will be evaluated as value expressions and passed to the 
            <code class="literal">bookHotel()</code> method of the component. 
         </p><p>
            Any value expression may be used as a parameter: 
         </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XHTML"><!-- XHTML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">h:commandButton</span><span class="xml_plain">&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">action</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;#{hotelBooking.bookHotel(hotel.id,&nbsp;user.username)}&quot;</span><span class="xml_plain">&nbsp;</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">value</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Book&nbsp;Hotel&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
</pre><p>
            It's important to fully understand how this extension to EL works. 
            When the page is rendered, the parameter <span class="emphasis"><em>names</em></span> 
            are stored (for example, <code class="literal">hotel.id</code> and 
            <code class="literal">user.username</code>), and evaluated (as value 
            expressions) when the page is submitted. You can't pass objects as
            parameters! 
         </p><p>
            You must ensure that the parameters are available not only when the 
            page is rendered, but also when it is submittedIf the arguments can 
            not be resolved when the page is submitted the action method will be
            called with <code class="literal">null</code> arguments! 
         </p><p>
            You can also pass literal strings using single quotes: 
         </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XHTML"><!-- XHTML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">h:commandLink</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">action</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;#{printer.println('Hello&nbsp;world!')}&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">value</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Hello&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
</pre><p> 
            Unified EL also supports value expressions, used to bind a field to 
            a backing bean. Value expressions use JavaBean naming conventions 
            and expect a getter/setter pair. Often JSF expects a value 
            expression where only retrieval (get) is needed (e.g. the 
            <code class="literal">rendered</code> attribute). Many objects, however, don't 
            have appropriately named property accessors or require parameters. 
         </p><p>
            JBoss EL removes this restriction by allowing values to be retrieved
            using the method syntax. For example: 
         </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XHTML"><!-- XHTML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">h:outputText</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">value</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;#{person.name}&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">rendered</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;#{person.name.length()&nbsp;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">&nbsp;5}</span><span class="xml_attribute_value">&quot;&nbsp;/</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>
            You can access the size of a collection in a similar manner: 
         </p><pre class="programlisting">#{searchResults.size()}</pre><p>
            In general any expression of the form #{obj.property} would be 
            identical to the expression #{obj.getProperty()}. 
         </p><p>
            Parameters are also allowed. The following example calls the
            <code class="literal">productsByColorMethod</code> with a literal string 
            argument: 
         </p><pre class="programlisting">#{controller.productsByColor('blue')}</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e29438"/>34.1.2. Limitations and Hints</h3></div></div></div><p> 
            When using JBoss EL you should keep the following points in mind: 
         </p><div class="itemizedlist"><ul><li><p>
                  <span class="emphasis"><em>Incompatibility with JSP 2.1</em></span> — 
                  JBoss EL can't currently be used with JSP 2.1 as the compiler 
                  rejects expressions with parameters in. So, if you want to use
                  this extension with JSF 1.2, you will need to use Facelets. 
                  The extension works correctly with JSP 2.0. 
               </p></li><li><p>
                  <span class="emphasis"><em>Use inside iterative components</em></span> — 
                  Components like <code class="literal">&lt;c:forEach /&gt;</code> and 
                  <code class="literal">&lt;ui:repeat /&gt;</code>iterate over a List or 
                  array, exposing each item in the list to nested components. 
                  This works great if you are selecting a row using a 
                  <code class="literal">&lt;h:commandButton /&gt;</code> or 
                  <code class="literal">&lt;h:commandLink /&gt;</code>: 
               </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">@</span><!-- <br/> --><span class="java_type">Factory</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">&quot;items&quot;</span><!-- <br/> --><span class="java_separator">)</span>
<!--  --><br/><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">List</span><span class="java_operator">&lt;</span><span class="java_type">Item</span><span class="java_operator">&gt;</span><span class="java_plain">&nbsp;getItems</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">return</span><span class="java_plain">&nbsp;entityManager</span><span class="java_separator">.</span><span class="java_plain">createQuery</span><span class="java_separator">(</span><span class="java_literal">&quot;select&nbsp;...&quot;</span><span class="java_separator">).</span><span class="java_plain">getResultList</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span></pre><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XHTML"><!-- XHTML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">h:dataTable</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">value</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;#{items}&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">var</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;item&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">h:column</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">h:commandLink</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">value</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Select&nbsp;#{item.name}&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">action</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;#{itemSelector.select(item})&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">h:column</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">h:dataTable</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>
                  However if you want to use <code class="literal">&lt;s:link /&gt;</code>
                  or <code class="literal">&lt;s:button /&gt;</code> you 
                  <span class="emphasis"><em>must</em></span> expose the items as a 
                  <code class="literal">DataModel</code>, and use a 
                  <code class="literal">&lt;dataTable /&gt;</code> (or equivalent from a 
                  component set like <code class="literal">&lt;rich:dataTable /&gt;</code>
                  ). Neither <code class="literal">&lt;s:link /&gt;</code> or 
                  <code class="literal">&lt;s:button /&gt;</code> submit the form (and
                  therefore produce a bookmarkable link) so a "magic" parameter
                  is needed to recreate the item when the action method is 
                  called. This magic parameter can only be added when a 
                  data table backed by a <code class="literal">DataModel</code> is used.
               </p></li><li><p>
                  <span class="emphasis"><em>Calling a <code class="literal">MethodExpression</code> from 
                  Java code</em></span> — Normally, when a 
                  <code class="literal">MethodExpression</code> is created, the parameter 
                  types are passed in by JSF. In the case of a method binding, 
                  JSF assumes that there are no parameters to pass. With this
                  extension, we can't know the parameter types until after the 
                  expression has been evaluated. This has two minor 
                  consequences: 
               </p><div class="itemizedlist"><ul><li><p> 
                        When you invoke a <code class="literal">MethodExpression</code> in
                        Java code, parameters you pass may be ignored. 
                        Parameters defined in the expression will take 
                        precedence. 
                     </p></li><li><p>
                        Ordinarily, it is safe to call 
                        <code class="literal">methodExpression.getMethodInfo().getParamTypes()</code>
                        at any time. For an expression with parameters, you must 
                        first invoke the <code class="literal">MethodExpression</code> 
                        before calling <code class="literal">getParamTypes()</code>. 
                     </p></li></ul></div><p>
                  Both of these cases are exceedingly rare and only apply when 
                  you want to invoke the <code class="literal">MethodExpression</code> by 
                  hand in Java code. 
               </p></li></ul></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e29537"/>34.2. Projection</h2></div></div></div><p>
         JBoss EL supports a limited projection syntax. A projection expression 
         maps a sub-expression across a multi-valued (list, set, etc...) 
         expression. For instance, the expression: 
      </p><pre class="programlisting">#{company.departments}</pre><p>
         might return a list of departments. If you only need a list of 
         department names, your only option is to iterate over the list to 
         retrieve the values. JBoss EL allows this with a projection expression: 
      </p><pre class="programlisting">#{company.departments.{d|d.name}}</pre><p>
         The subexpression is enclosed in braces. In this example, the 
         expression <code class="literal">d.name</code> is evaluated for each department, 
         using <code class="literal">d</code> as an alias to the department object. The 
         result of this expression will be a list of String values. 
      </p><p>
         Any valid expression can be used in an expression, so it would be 
         perfectly valid to write the following, assuming you had a use for the 
         lengths of all the department names in a company: 
      </p><pre class="programlisting">#{company.departments.{d|d.size()}}</pre><p>
         Projections can be nested. The following expression returns the last 
         names of every employee in every department: 
      </p><pre class="programlisting">#{company.departments.{d|d.employees.{emp|emp.lastName}}}</pre><p> 
         Nested projections can be slightly tricky, however. The following 
         expression looks like it returns a list of all the employees in all the 
         departments:
      </p><pre class="programlisting">#{company.departments.{d|d.employees}}</pre><p>
         However, it actually returns a list containing a list of the employees 
         for each individual department. To combine the values, it is necessary 
         to use a slightly longer expression: 
      </p><pre class="programlisting">#{company.departments.{d|d.employees.{e|e}}}</pre><p> 
         It is important to note that this syntax cannot be parsed by Facelets
         or JSP and thus cannot be used in xhtml or JSP files. We anticipate 
         that the projection syntax will change in future versions of JBoss EL. 
      </p></div></div><ul class="docnav"><li class="previous"><a accesskey="p" href="controls.html"><strong>Prev</strong>Chapter 33. Seam JSF controls</a></li><li class="up"><a accesskey="u" href="#"><strong>Top of page</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Front page</strong></a></li><li class="next"><a accesskey="n" href="ClusteringAndEJBPassivation.html"><strong>Next</strong>Chapter 35. Clustering and EJB Passivation</a></li></ul></body></html>